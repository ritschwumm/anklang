<!-- This Source Code Form is licensed MPL-2.0: http://mozilla.org/MPL/2.0 -->

<docs>
  # B-TRACKLIST
  A container for vertical display of Ase.Track instances.
  ## Props:
  *project*
  : The *Ase.Project* containing playback tracks.
</docs>

<style lang="scss">
  @import 'mixins.scss';
  $b-tracklist-arranger-lpad: 3px;
  $b-track-scrollelement-bg: transparent;
  $scrollbar-area-size: 12px;
  .b-tracklist {
    background-color: $b-tracklist-bg;
    //* Layout: Tracks Spacer Clips Spacer Parts Scrollbar */
    grid-template-columns: min-content 3px 17fr 3px 10px 20px;
    //* Layout: Header Spacer Main Spacer Footer */
    grid-template-rows: min-content 3px 1fr 3px 20px;
  }
  .b-trackrow-cell {
    flex-shrink: 0;
    height: $b-trackrow-height;
    margin: calc($b-panel-spacing * 0.5) 0;
  }
  .b-tracklist-trackswrapper {
    padding-top: calc($b-panel-spacing * 0.5); padding-bottom: calc($b-panel-spacing * 0.5);
    padding-left: calc($b-panel-spacing * 0.5);
  }
  .b-tracklist-theader, .b-tracklist-tfooter, .b-tracklist-trackswrapper {
    margin-left: calc($b-panel-spacing * 0.5);
  }
  .b-tracklist-clipswrapper {
    display: inline-flex;
    padding-top: calc($b-panel-spacing * 0.5); padding-bottom: calc($b-panel-spacing * 0.5);
  }
  .b-tracklist-cheader, .b-tracklist-hscrollbar1, .b-tracklist-clipswrapper {
    margin: 0 $b-panel-spacing;
  }
  .b-tracklist-partswrapper {
    display: inline-flex;
    padding-top: calc($b-panel-spacing * 0.5); padding-bottom: calc($b-panel-spacing * 0.5);
    padding-right: calc($b-panel-spacing * 0.5);
  }
  .b-tracklist-vscrollbar {
    display: flex;
    justify-self: center;
    width: $scrollbar-area-size;
    height: -moz-available; height: -webkit-fill-available; height: fill-available; height: auto;
    background: $b-track-scrollelement-bg;
    overflow-y: scroll;
    overflow-x: hidden;
    .b-tracklist-vscrollbar-elemnt {
      width: 1px;
      height: 0;
    }
  }
  .b-tracklist-hscrollbar1,
  .b-tracklist-hscrollbar2 {
    display: flex; flex-direction: column;
    align-self: center;
    height: $scrollbar-area-size;
    width: -moz-available; width: -webkit-fill-available; width: fill-available; width: auto;
    background: $b-track-scrollelement-bg;
    overflow-x: scroll;
    overflow-y: hidden;
    .b-tracklist-hscrollbar-elemnt {
      height: 1px;
      width: 0;
    }
  }
  .b-tracklist-tracks,
  .b-tracklist-clips,
  .b-tracklist-parts {
    position: relative;
    white-space: nowrap;
    overflow: hidden;
    background: $b-tracklist-parts-bg;
  }
  .b-tracklist-tracks-shadow,
  .b-tracklist-clips-shadow,
  .b-tracklist-parts-shadow {
    position: absolute; //* Note, 'position:sticky' increases parent layout */
    left: 0; top: 0; will-change: left, top;
    width: 100%; height: 100%;
    z-index: 1;
    pointer-events: none;
    box-shadow: 0px 0px $b-scroll-shadow-blur 0px inset #000;
  }
  .b-tracklist-tickpointer {
    position: absolute; height: 100%; display: flex;
    transform: translateX(0px);
    left: calc($b-tracklist-arranger-lpad - 3px);
    /* width: 1px; background: #fff8; border: 1px solid #0008; box-sizing: content-box; */
    width: 3px; background: linear-gradient(to right, #0f00, #0f08 80%, #0f0f);
  }
</style>

<template>

  <c-grid class="b-tracklist" @dblclick.stop="list_dblclick" >
    <!-- Headers, ROW-1 -->
    <span class="b-tracklist-theader" > Tracks </span>
    <!-- Gap -->
    <span class="b-tracklist-vgap1" />
    <span class="b-tracklist-cheader" > Clips </span>
    <!-- Gap -->
    <span class="b-tracklist-vgap2" />
    <span class="b-tracklist-pheader" > Timeline... </span>
    <span > s </span>
    <!-- Gap, ROW-2 -->
    <span class="b-tracklist-hgap1" style="grid-row-start: 2; grid-column: 1/-1" />
    <!-- Tracks, ROW-3 -->
    <div class="b-tracklist-tracks" style="grid-column-start: 1; grid-row-start: 3" ref="tracks"
	 @wheel.stop="Util.wheel2scrollbars ($event, $refs, 'vscrollbar')" >
      <v-flex class="b-tracklist-trackswrapper" ref="trackswrapper" >
	<b-trackview class="b-trackrow-cell"
		     v-for="(pair, tindex) in tdata.tracks" :key="pair[1]"
		     :track="pair[0]" :trackindex="tindex"></b-trackview>
      </v-flex>
      <div class="b-tracklist-tracks-shadow" ref="tracksshadow" ></div>
    </div>
    <!-- Gap -->
    <span class="b-tracklist-vgap1" />
    <!-- Clips -->
    <div class="b-tracklist-clips" ref="clips"
	 @wheel.stop="Util.wheel2scrollbars ($event, $refs, 'hscrollbar1', 'vscrollbar')" >
      <v-flex class="b-tracklist-clipswrapper" ref="clipswrapper" >
	<b-cliplist class="b-trackrow-cell" v-for="(pair, tindex) in tdata.tracks" :key="pair[1]"
		    :track="pair[0]" :trackindex="tindex" />
      </v-flex>
      <div class="b-tracklist-clips-shadow" ref="clipsshadow" ></div>
    </div>
    <!-- Gap -->
    <span class="b-tracklist-vgap2" />
    <!-- Parts -->
    <div class="b-tracklist-parts" ref="parts"
	 @wheel.stop="Util.wheel2scrollbars ($event, $refs, 'hscrollbar2', 'vscrollbar')" >
      <v-flex class="b-tracklist-partswrapper" ref="partswrapper" >
	<b-partlist class="b-trackrow-cell"
		    v-for="(pair, tindex) in tdata.tracks" :key="pair[1]"
		    :track="pair[0]" :trackindex="tindex"></b-partlist>
	<span class="b-tracklist-tickpointer" ref="tickpointer"></span>
      </v-flex>
      <div class="b-tracklist-parts-shadow" ref="partsshadow" ></div>
    </div>
    <!-- VScrollbar -->
    <div class="b-tracklist-vscrollbar" ref="vscrollbar" >
      <div class="b-tracklist-vscrollbar-elemnt" ref="vscrollbar_element" ></div>
    </div>
    <!-- Gap, ROW-4 -->
    <span class="b-tracklist-hgap2" style="grid-row-start: 4; grid-column: 1/-1" />
    <!-- Footer, ROW-5 -->
    <span class="b-tracklist-tfooter" style="grid-row-start: 5" > Footer </span>
    <!-- Gap -->
    <span class="b-tracklist-vgap1" />
    <!-- HScrollbar1 -->
    <div class="b-tracklist-hscrollbar1" ref="hscrollbar1" >
      <div class="b-tracklist-hscrollbar-elemnt" ref="hscrollbar1_element" ></div>
    </div>
    <!-- Gap -->
    <span class="b-tracklist-vgap2" />
    <!-- HScrollbar2 -->
    <div class="b-tracklist-hscrollbar2" ref="hscrollbar2" >
      <div class="b-tracklist-hscrollbar-elemnt" ref="hscrollbar2_element" ></div>
    </div>
    <!-- Corner -->
    <span > c </span>
  </c-grid>

</template>

<script>
import * as Ase from '../aseapi.js';

async function list_tracks () {
  let tracks = await this.project.list_tracks();
  tracks = tracks.map (trk => [trk, trk.$id]);
  return tracks; // [ [track,uniqnum], ...]
}

async function tick_moniotr (addcleanup) {
  if (1) return null; // TODO: implement ProjectTelemetry
  const mon = {};
  // retrieve SHM locations
  let tickpos_offset = this.project.get_shm_offset (Ase.ProjectTelemetry.I32_TICK_POINTER);
  // subscribe to SHM updates
  tickpos_offset = await tickpos_offset;
  mon.sub_i32tickpos = Util.shm_subscribe (tickpos_offset, 4);
  // register cleanups
  const dtor = () => {
    Util.shm_unsubscribe (mon.sub_i32tickpos);
  };
  addcleanup (dtor);
  // return value
  return mon;
}

function tracklist_data () {
  const tdata = {
    tracks: { getter: c => list_tracks.call (this), notify: n => this.project.on ("track", n), },
    tmon:   { getter: c => tick_moniotr.call (this, c), },
  };
  return this.observable_from_getters (tdata, () => this.project);
}

export default {
  sfc_template,
  props: {
    project: { type: Ase.Project }
  },
  data() { return {
    tdata: tracklist_data.call (this),
  }; },
  mounted() {
    // vscrollbar
    const sync_vscrollbar_size = () => {
      let vscroll_pxheight = '0px';
      if (this.$refs.tracks)
	vscroll_pxheight = this.$refs.tracks.scrollHeight + 'px';
      if (this.$refs.vscrollbar_element)
	this.$refs.vscrollbar_element.style.height = vscroll_pxheight;
      if (this.$refs.tickpointer)
	this.$refs.tickpointer.style.height = vscroll_pxheight;
      // $refs.tracks.scrollHeight changes with $refs.trackswrapper.height
    };
    this.vscrollbar_observer = new Util.ResizeObserver (sync_vscrollbar_size);
    this.vscrollbar_observer.observe (this.$refs.trackswrapper);
    const sync_vscrollbar_pos = e => {
      const scrolltop = this.$refs.vscrollbar.scrollTop;
      this.$refs.tracks.scrollTop = scrolltop;
      this.$refs.clips.scrollTop = scrolltop;
      this.$refs.parts.scrollTop = scrolltop;
      const scrolltoppx = scrolltop + 'px';
      this.$refs.tracksshadow.style.top = scrolltoppx;
      this.$refs.clipsshadow.style.top = scrolltoppx;
      this.$refs.partsshadow.style.top = scrolltoppx;
    };
    this.$refs.vscrollbar.onscroll = sync_vscrollbar_pos;
    sync_vscrollbar_size();
    // hscrollbar1
    const sync_hscrollbar1_size = () => {
      if (this.$refs.hscrollbar1_element)
	this.$refs.hscrollbar1_element.style.width = this.$refs.clipswrapper.scrollWidth + 'px';
      // $refs.clips.scrollWidth changes with $refs.clipswrapper.width
    };
    this.hscrollbar1_observer = new Util.ResizeObserver (sync_hscrollbar1_size);
    this.hscrollbar1_observer.observe (this.$refs.clipswrapper);
    const sync_hscrollbar1_pos = e => {
      this.$refs.clips.scrollLeft = this.$refs.hscrollbar1.scrollLeft;
      this.$refs.clipsshadow.style.left = this.$refs.hscrollbar1.scrollLeft + 'px';
    };
    this.$refs.hscrollbar1.onscroll = sync_hscrollbar1_pos;
    sync_hscrollbar1_size();
    // hscrollbar2
    const sync_hscrollbar2_size = () => {
      if (this.$refs.hscrollbar2_element)
	this.$refs.hscrollbar2_element.style.width = this.$refs.partswrapper.scrollWidth + 'px';
      // $refs.parts.scrollWidth changes with $refs.partswrapper.width
    };
    this.hscrollbar2_observer = new Util.ResizeObserver (sync_hscrollbar2_size);
    this.hscrollbar2_observer.observe (this.$refs.partswrapper);
    const sync_hscrollbar2_pos = e => {
      this.$refs.parts.scrollLeft = this.$refs.hscrollbar2.scrollLeft;
      this.$refs.partsshadow.style.left = this.$refs.hscrollbar2.scrollLeft + 'px';
    };
    this.$refs.hscrollbar2.onscroll = sync_hscrollbar2_pos;
    sync_hscrollbar2_size();
    // TODO: part-thumbs are placed with position:absolute, so their containers have
    // width=0 and hscrollbar2_observer isn't triggered on width changes (scrollWidth
    // is correct nevertheless but cannot be observed).
    // The fix here is to implement the timeline with correct width and relative positioning
    // until then we employ a hover hack.
    this.$refs.hscrollbar2.onpointerover = sync_hscrollbar2_size;
    setTimeout (sync_hscrollbar2_size, 1555); // fixup after project loading
  },
  beforeUnmount () {
  },
  methods:  {
    list_dblclick (event) {
      Data.project?.create_track();
    },
    dom_update() {
      this.last_tickpos = -1;
      // this.dom_trigger_animate_playback (false);
      if (this.project && this.tdata.tmon)
	{
	  this.i32tickpos = this.tdata.tmon.sub_i32tickpos[0] / 4;
	  // this.dom_trigger_animate_playback (true);
	}
    },
    dom_animate_playback (active) {
      const tickpointer = this.$refs.tickpointer;
      if (tickpointer && this.i32tickpos)
	{
	  const tickpos = Util.shm_array_int32[this.i32tickpos];
	  if (this.last_tickpos != tickpos)
	    {
	      const tickscale = 10.0 / Util.PPQN;
	      const transform = 'translateX(+' + Math.round (tickpos * tickscale) + 'px)';
	      if (transform != tickpointer.style.getPropertyValue ('transform')) // reduce style recalculations
		tickpointer.style.setProperty ('transform', transform);
	      this.last_tickpos = tickpos;
	    }
	}
    },
  },
};
</script>
